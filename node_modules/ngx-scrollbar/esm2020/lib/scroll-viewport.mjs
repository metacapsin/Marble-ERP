import { Directive } from '@angular/core';
import { fromEvent, merge, Observable } from 'rxjs';
import { map, switchMap, takeUntil, tap } from 'rxjs/operators';
import { stopPropagation } from './scrollbar/common';
import * as i0 from "@angular/core";
export class ScrollViewport {
    // Get viewport size, clientHeight or clientWidth
    get clientHeight() {
        return this.nativeElement.clientHeight;
    }
    get clientWidth() {
        return this.nativeElement.clientWidth;
    }
    get scrollHeight() {
        return this.nativeElement.scrollHeight;
    }
    get scrollWidth() {
        return this.nativeElement.scrollWidth;
    }
    // Get viewport scroll offset, scrollTop or scrollLeft
    get scrollTop() {
        return this.nativeElement.scrollTop;
    }
    get scrollLeft() {
        return this.nativeElement.scrollLeft;
    }
    // Get the available scrollable size
    get scrollMaxX() {
        return this.scrollWidth - this.clientWidth;
    }
    get scrollMaxY() {
        return this.scrollHeight - this.clientHeight;
    }
    get contentHeight() {
        return this.contentWrapperElement?.clientHeight || 0;
    }
    get contentWidth() {
        return this.contentWrapperElement?.clientWidth || 0;
    }
    constructor(viewPort) {
        this.viewPort = viewPort;
        this.nativeElement = viewPort.nativeElement;
    }
    /**
     * Activate viewport pointer events such as 'hovered' and 'clicked' events
     */
    activatePointerEvents(propagate, destroyed) {
        this.hovered = new Observable((subscriber) => {
            // Stream that emits when pointer is moved over the viewport (used to set the hovered state)
            const mouseMoveStream = fromEvent(this.nativeElement, 'mousemove', { passive: true });
            const mouseMove = propagate ? mouseMoveStream : mouseMoveStream.pipe(stopPropagation());
            // Stream that emits when pointer leaves the viewport (used to remove the hovered state)
            const mouseLeave = fromEvent(this.nativeElement, 'mouseleave', { passive: true }).pipe(map(() => false));
            merge(mouseMove, mouseLeave).pipe(tap((e) => subscriber.next(e)), takeUntil(destroyed)).subscribe();
        });
        this.clicked = new Observable((subscriber) => {
            const mouseDown = fromEvent(this.nativeElement, 'mousedown', { passive: true }).pipe(tap((e) => subscriber.next(e)));
            const mouseUp = fromEvent(this.nativeElement, 'mouseup', { passive: true }).pipe(tap(() => subscriber.next(false)));
            mouseDown.pipe(switchMap(() => mouseUp), takeUntil(destroyed)).subscribe();
        });
    }
    /**
     * Set this directive as a non-functional wrapper, called when a custom viewport is used
     */
    setAsWrapper() {
        // In this case the default viewport and the default content wrapper will act as a mask
        this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';
        if (this.nativeElement.firstElementChild) {
            this.nativeElement.firstElementChild.className = 'ng-scroll-layer';
        }
    }
    /**
     * Set this directive as  the viewport, called when no custom viewport is used
     */
    setAsViewport(customClassName) {
        this.nativeElement.className = `ng-native-scrollbar-hider ng-scroll-viewport ${customClassName}`;
        // Check if the custom viewport has only one child and set it as the content wrapper
        if (this.nativeElement.firstElementChild) {
            this.contentWrapperElement = this.nativeElement.firstElementChild;
            this.contentWrapperElement.classList.add('ng-scroll-content');
        }
    }
    /**
     * Scroll viewport vertically
     */
    scrollYTo(value) {
        this.nativeElement.scrollTop = value;
    }
    /**
     * Scroll viewport horizontally
     */
    scrollXTo(value) {
        this.nativeElement.scrollLeft = value;
    }
}
ScrollViewport.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: ScrollViewport, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
ScrollViewport.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.4", type: ScrollViewport, selector: "[scrollViewport]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: ScrollViewport, decorators: [{
            type: Directive,
            args: [{
                    selector: '[scrollViewport]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLXZpZXdwb3J0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zcmMvbGliL3Njcm9sbC12aWV3cG9ydC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFjLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUNoRSxPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDaEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDOztBQUtyRCxNQUFNLE9BQU8sY0FBYztJQVd6QixpREFBaUQ7SUFDakQsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztJQUN4QyxDQUFDO0lBRUQsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztJQUN4QyxDQUFDO0lBRUQsc0RBQXNEO0lBQ3RELElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUM7SUFDdEMsQ0FBQztJQUVELElBQUksVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7SUFDdkMsQ0FBQztJQUVELG9DQUFvQztJQUNwQyxJQUFJLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUM3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LGFBQWEsQ0FBQyxlQUF1QjtRQUNuQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsR0FBRyxnREFBZ0QsZUFBZSxFQUFFLENBQUM7UUFDakcsb0ZBQW9GO1FBQ3BGLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsRUFBRTtZQUN4QyxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxpQkFBZ0MsQ0FBQztZQUNqRixJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQy9EO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsU0FBUyxDQUFDLEtBQWE7UUFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7T0FFRztJQUNILFNBQVMsQ0FBQyxLQUFhO1FBQ3JCLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztJQUN4QyxDQUFDOzsyR0EzSFUsY0FBYzsrRkFBZCxjQUFjOzJGQUFkLGNBQWM7a0JBSDFCLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGtCQUFrQjtpQkFDN0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgZnJvbUV2ZW50LCBtZXJnZSwgT2JzZXJ2YWJsZSwgU3Vic2NyaWJlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAsIHN3aXRjaE1hcCwgdGFrZVVudGlsLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IHN0b3BQcm9wYWdhdGlvbiB9IGZyb20gJy4vc2Nyb2xsYmFyL2NvbW1vbic7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tzY3JvbGxWaWV3cG9ydF0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxWaWV3cG9ydCB7XHJcbiAgLy8gVmlld3BvcnQgZWxlbWVudFxyXG4gIHJlYWRvbmx5IG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gIC8vIENvbnRlbnQgd3JhcHBlciBlbGVtZW50XHJcbiAgY29udGVudFdyYXBwZXJFbGVtZW50ITogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcG9pbnRlciBldmVudCB3aGVuIHRoZSB2aWV3cG9ydCBpcyBob3ZlcmVkIGFuZCBlbWl0cyBmYWxzZSB2YWx1ZSB3aGVuIGlzbid0IGhvdmVyZWRcclxuICBob3ZlcmVkITogT2JzZXJ2YWJsZTxNb3VzZUV2ZW50IHwgZmFsc2U+O1xyXG4gIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gdmlld3BvcnQgaXMgY2xpY2tlZFxyXG4gIGNsaWNrZWQhOiBPYnNlcnZhYmxlPE1vdXNlRXZlbnQgfCBmYWxzZT47XHJcblxyXG4gIC8vIEdldCB2aWV3cG9ydCBzaXplLCBjbGllbnRIZWlnaHQgb3IgY2xpZW50V2lkdGhcclxuICBnZXQgY2xpZW50SGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICB9XHJcblxyXG4gIGdldCBjbGllbnRXaWR0aCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5jbGllbnRXaWR0aDtcclxuICB9XHJcblxyXG4gIGdldCBzY3JvbGxIZWlnaHQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNjcm9sbFdpZHRoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHZpZXdwb3J0IHNjcm9sbCBvZmZzZXQsIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0XHJcbiAgZ2V0IHNjcm9sbFRvcCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5zY3JvbGxUb3A7XHJcbiAgfVxyXG5cclxuICBnZXQgc2Nyb2xsTGVmdCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0O1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRoZSBhdmFpbGFibGUgc2Nyb2xsYWJsZSBzaXplXHJcbiAgZ2V0IHNjcm9sbE1heFgoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoIC0gdGhpcy5jbGllbnRXaWR0aDtcclxuICB9XHJcblxyXG4gIGdldCBzY3JvbGxNYXhZKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxIZWlnaHQgLSB0aGlzLmNsaWVudEhlaWdodDtcclxuICB9XHJcblxyXG4gIGdldCBjb250ZW50SGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250ZW50V3JhcHBlckVsZW1lbnQ/LmNsaWVudEhlaWdodCB8fCAwO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNvbnRlbnRXaWR0aCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGVudFdyYXBwZXJFbGVtZW50Py5jbGllbnRXaWR0aCB8fCAwO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHVibGljIHZpZXdQb3J0OiBFbGVtZW50UmVmKSB7XHJcbiAgICB0aGlzLm5hdGl2ZUVsZW1lbnQgPSB2aWV3UG9ydC5uYXRpdmVFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWN0aXZhdGUgdmlld3BvcnQgcG9pbnRlciBldmVudHMgc3VjaCBhcyAnaG92ZXJlZCcgYW5kICdjbGlja2VkJyBldmVudHNcclxuICAgKi9cclxuICBhY3RpdmF0ZVBvaW50ZXJFdmVudHMocHJvcGFnYXRlOiBib29sZWFuLCBkZXN0cm95ZWQ6IE9ic2VydmFibGU8dm9pZD4pOiB2b2lkIHtcclxuICAgIHRoaXMuaG92ZXJlZCA9IG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPE1vdXNlRXZlbnQgfCBmYWxzZT4pID0+IHtcclxuICAgICAgLy8gU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBwb2ludGVyIGlzIG1vdmVkIG92ZXIgdGhlIHZpZXdwb3J0ICh1c2VkIHRvIHNldCB0aGUgaG92ZXJlZCBzdGF0ZSlcclxuICAgICAgY29uc3QgbW91c2VNb3ZlU3RyZWFtID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KHRoaXMubmF0aXZlRWxlbWVudCwgJ21vdXNlbW92ZScsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgY29uc3QgbW91c2VNb3ZlID0gcHJvcGFnYXRlID8gbW91c2VNb3ZlU3RyZWFtIDogbW91c2VNb3ZlU3RyZWFtLnBpcGUoc3RvcFByb3BhZ2F0aW9uKCkpO1xyXG4gICAgICAvLyBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHBvaW50ZXIgbGVhdmVzIHRoZSB2aWV3cG9ydCAodXNlZCB0byByZW1vdmUgdGhlIGhvdmVyZWQgc3RhdGUpXHJcbiAgICAgIGNvbnN0IG1vdXNlTGVhdmUgPSBmcm9tRXZlbnQ8ZmFsc2U+KHRoaXMubmF0aXZlRWxlbWVudCwgJ21vdXNlbGVhdmUnLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShtYXAoKCkgPT4gZmFsc2UpKTtcclxuICAgICAgbWVyZ2UobW91c2VNb3ZlLCBtb3VzZUxlYXZlKS5waXBlKFxyXG4gICAgICAgIHRhcCgoZTogTW91c2VFdmVudCB8IGZhbHNlKSA9PiBzdWJzY3JpYmVyLm5leHQoZSkpLFxyXG4gICAgICAgIHRha2VVbnRpbChkZXN0cm95ZWQpXHJcbiAgICAgICkuc3Vic2NyaWJlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmNsaWNrZWQgPSBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxNb3VzZUV2ZW50IHwgZmFsc2U+KSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vdXNlRG93biA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pih0aGlzLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWRvd24nLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShcclxuICAgICAgICB0YXAoKGU6IE1vdXNlRXZlbnQpID0+IHN1YnNjcmliZXIubmV4dChlKSlcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgbW91c2VVcCA9IGZyb21FdmVudDxmYWxzZT4odGhpcy5uYXRpdmVFbGVtZW50LCAnbW91c2V1cCcsIHsgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKFxyXG4gICAgICAgIHRhcCgoKSA9PiBzdWJzY3JpYmVyLm5leHQoZmFsc2UpKVxyXG4gICAgICApO1xyXG4gICAgICBtb3VzZURvd24ucGlwZShcclxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gbW91c2VVcCksXHJcbiAgICAgICAgdGFrZVVudGlsKGRlc3Ryb3llZClcclxuICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoaXMgZGlyZWN0aXZlIGFzIGEgbm9uLWZ1bmN0aW9uYWwgd3JhcHBlciwgY2FsbGVkIHdoZW4gYSBjdXN0b20gdmlld3BvcnQgaXMgdXNlZFxyXG4gICAqL1xyXG4gIHNldEFzV3JhcHBlcigpOiB2b2lkIHtcclxuICAgIC8vIEluIHRoaXMgY2FzZSB0aGUgZGVmYXVsdCB2aWV3cG9ydCBhbmQgdGhlIGRlZmF1bHQgY29udGVudCB3cmFwcGVyIHdpbGwgYWN0IGFzIGEgbWFza1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZSA9ICduZy1uYXRpdmUtc2Nyb2xsYmFyLWhpZGVyIG5nLXNjcm9sbC1sYXllcic7XHJcbiAgICBpZiAodGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSB7XHJcbiAgICAgIHRoaXMubmF0aXZlRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5jbGFzc05hbWUgPSAnbmctc2Nyb2xsLWxheWVyJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGlzIGRpcmVjdGl2ZSBhcyAgdGhlIHZpZXdwb3J0LCBjYWxsZWQgd2hlbiBubyBjdXN0b20gdmlld3BvcnQgaXMgdXNlZFxyXG4gICAqL1xyXG4gIHNldEFzVmlld3BvcnQoY3VzdG9tQ2xhc3NOYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMubmF0aXZlRWxlbWVudC5jbGFzc05hbWUgPSBgbmctbmF0aXZlLXNjcm9sbGJhci1oaWRlciBuZy1zY3JvbGwtdmlld3BvcnQgJHtjdXN0b21DbGFzc05hbWV9YDtcclxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXN0b20gdmlld3BvcnQgaGFzIG9ubHkgb25lIGNoaWxkIGFuZCBzZXQgaXQgYXMgdGhlIGNvbnRlbnQgd3JhcHBlclxyXG4gICAgaWYgKHRoaXMubmF0aXZlRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkge1xyXG4gICAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWxlbWVudCA9IHRoaXMubmF0aXZlRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgdGhpcy5jb250ZW50V3JhcHBlckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbmctc2Nyb2xsLWNvbnRlbnQnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbCB2aWV3cG9ydCB2ZXJ0aWNhbGx5XHJcbiAgICovXHJcbiAgc2Nyb2xsWVRvKHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbCB2aWV3cG9ydCBob3Jpem9udGFsbHlcclxuICAgKi9cclxuICBzY3JvbGxYVG8odmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSB2YWx1ZTtcclxuICB9XHJcbn1cclxuIl19