import { Directive, Optional, Input, Output } from '@angular/core';
import { Observable, Subject, Subscription } from 'rxjs';
import { filter, map, tap, distinctUntilChanged } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "ngx-scrollbar";
import * as i2 from "@angular/cdk/bidi";
class ReachedFunctions {
    static reachedTop(offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    }
    static reachedBottom(offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    }
    static reachedStart(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    }
    static reachedEnd(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    }
    static reached(currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    }
}
class ScrollReached {
    constructor(scrollbar, zone) {
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** offset: Reached offset value in px */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /** subscription: Scrolled event subscription, used to unsubscribe from the event on destroy */
        this.subscription = Subscription.EMPTY;
        /** A stream used to assign the reached output */
        this.reachedEvent = new Observable((subscriber) => this.scrollReached().subscribe(_ => Promise.resolve().then(() => this.zone.run(() => subscriber.next(_)))));
        if (!scrollbar) {
            console.warn('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    scrollReached() {
        // current event
        let currEvent;
        return this.scrollEvent.pipe(tap((e) => currEvent = e), 
        // Check if it scroll has reached
        map((e) => this.reached(this.offset, e)), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((reached) => reached), 
        // Return scroll event
        map(() => currEvent));
    }
}
ScrollReached.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: ScrollReached, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
ScrollReached.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.4", type: ScrollReached, inputs: { offset: ["reachedOffset", "offset"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: ScrollReached, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; }, propDecorators: { offset: [{
                type: Input,
                args: ['reachedOffset']
            }] } });
class VerticalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    }
}
VerticalScrollReached.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: VerticalScrollReached, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
VerticalScrollReached.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.4", type: VerticalScrollReached, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: VerticalScrollReached, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; } });
class HorizontalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    }
}
HorizontalScrollReached.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: HorizontalScrollReached, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
HorizontalScrollReached.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.4", type: HorizontalScrollReached, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: HorizontalScrollReached, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; } });
export class NgScrollbarReachedTop extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the top */
        this.reachedTop = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    }
}
NgScrollbarReachedTop.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: NgScrollbarReachedTop, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgScrollbarReachedTop.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.4", type: NgScrollbarReachedTop, selector: "[reachedTop], [reached-top]", outputs: { reachedTop: "reachedTop" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: NgScrollbarReachedTop, decorators: [{
            type: Directive,
            args: [{
                    selector: '[reachedTop], [reached-top]',
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; }, propDecorators: { reachedTop: [{
                type: Output
            }] } });
export class NgScrollbarReachedBottom extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the bottom */
        this.reachedBottom = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    }
}
NgScrollbarReachedBottom.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: NgScrollbarReachedBottom, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgScrollbarReachedBottom.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.4", type: NgScrollbarReachedBottom, selector: "[reachedBottom], [reached-bottom]", outputs: { reachedBottom: "reachedBottom" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: NgScrollbarReachedBottom, decorators: [{
            type: Directive,
            args: [{
                    selector: '[reachedBottom], [reached-bottom]',
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; }, propDecorators: { reachedBottom: [{
                type: Output
            }] } });
export class NgScrollbarReachedStart extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the start */
        this.reachedStart = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
}
NgScrollbarReachedStart.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: NgScrollbarReachedStart, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }, { token: i2.Directionality }], target: i0.ɵɵFactoryTarget.Directive });
NgScrollbarReachedStart.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.4", type: NgScrollbarReachedStart, selector: "[reachedStart], [reached-start]", outputs: { reachedStart: "reachedStart" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: NgScrollbarReachedStart, decorators: [{
            type: Directive,
            args: [{
                    selector: '[reachedStart], [reached-start]',
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }, { type: i2.Directionality }]; }, propDecorators: { reachedStart: [{
                type: Output
            }] } });
export class NgScrollbarReachedEnd extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the end */
        this.reachedEnd = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
}
NgScrollbarReachedEnd.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: NgScrollbarReachedEnd, deps: [{ token: i1.NgScrollbar, optional: true }, { token: i0.NgZone }, { token: i2.Directionality }], target: i0.ɵɵFactoryTarget.Directive });
NgScrollbarReachedEnd.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.4", type: NgScrollbarReachedEnd, selector: "[reachedEnd], [reached-end]", outputs: { reachedEnd: "reachedEnd" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: NgScrollbarReachedEnd, decorators: [{
            type: Directive,
            args: [{
                    selector: '[reachedEnd], [reached-end]',
                }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbar, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }, { type: i2.Directionality }]; }, propDecorators: { reachedEnd: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctc2Nyb2xsYmFyLXJlYWNoZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc2Nyb2xsYmFyL3JlYWNoZWQtZXZlbnQvc3JjL25nLXNjcm9sbGJhci1yZWFjaGVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQTZCLE1BQU0sZUFBZSxDQUFDO0FBSTlGLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUNyRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUt4RSxNQUFNLGdCQUFnQjtJQUNwQixNQUFNLENBQUMsVUFBVSxDQUFDLE1BQWMsRUFBRSxDQUFlO1FBQy9DLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLE1BQWMsRUFBRSxDQUFlO1FBQ2xELE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzdHLENBQUM7SUFFRCxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQWMsRUFBRSxDQUFlLEVBQUUsU0FBd0IsRUFBRSxpQkFBb0M7UUFDakgsSUFBSSxTQUFTLEtBQUssS0FBSyxFQUFFO1lBQ3ZCLElBQUksaUJBQWlCLHNDQUE4QixFQUFFO2dCQUNuRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDakU7WUFDRCxJQUFJLGlCQUFpQix1Q0FBK0IsRUFBRTtnQkFDcEQsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDbEU7WUFDRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUMzRztRQUNELE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQWMsRUFBRSxDQUFlLEVBQUUsU0FBd0IsRUFBRSxpQkFBb0M7UUFDL0csSUFBSSxTQUFTLEtBQUssS0FBSyxFQUFFO1lBQ3ZCLElBQUksaUJBQWlCLHNDQUE4QixFQUFFO2dCQUNuRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQzthQUM5RztZQUNELElBQUksaUJBQWlCLHVDQUErQixFQUFFO2dCQUNwRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQzthQUM5RztZQUNELE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ2xFO1FBQ0QsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDNUcsQ0FBQztJQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBb0IsRUFBRSxjQUFzQixFQUFFLE1BQWM7UUFDekUsT0FBTyxZQUFZLElBQUksY0FBYyxHQUFHLE1BQU0sQ0FBQztJQUNqRCxDQUFDO0NBQ0Y7QUFFRCxNQUNlLGFBQWE7SUFvQjFCLFlBQTRDLFNBQXNCLEVBQVksSUFBWTtRQUE5QyxjQUFTLEdBQVQsU0FBUyxDQUFhO1FBQVksU0FBSSxHQUFKLElBQUksQ0FBUTtRQWxCMUYseUNBQXlDO1FBQ2pCLFdBQU0sR0FBRyxDQUFDLENBQUM7UUFFbkM7Ozs7V0FJRztRQUNPLGdCQUFXLEdBQUcsSUFBSSxPQUFPLEVBQWdCLENBQUM7UUFFcEQsK0ZBQStGO1FBQ3JGLGlCQUFZLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQztRQUU1QyxpREFBaUQ7UUFDdkMsaUJBQVksR0FBRyxJQUFJLFVBQVUsQ0FBQyxDQUFDLFVBQW9DLEVBQUUsRUFBRSxDQUMvRSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQ2pDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRzFFLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDZCxPQUFPLENBQUMsSUFBSSxDQUFDLGdGQUFnRixDQUFDLENBQUM7U0FDaEc7SUFDSCxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVTLGFBQWE7UUFDckIsZ0JBQWdCO1FBQ2hCLElBQUksU0FBdUIsQ0FBQztRQUU1QixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUMxQixHQUFHLENBQUMsQ0FBQyxDQUFlLEVBQUUsRUFBRSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDdkMsaUNBQWlDO1FBQ2pDLEdBQUcsQ0FBQyxDQUFDLENBQWUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RELDJDQUEyQztRQUMzQyxvQkFBb0IsRUFBRTtRQUN0QiwrQkFBK0I7UUFDL0IsTUFBTSxDQUFDLENBQUMsT0FBZ0IsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDO1FBQ3JDLHNCQUFzQjtRQUN0QixHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQ3JCLENBQUM7SUFDSixDQUFDOzswR0E3Q1ksYUFBYTs4RkFBYixhQUFhOzJGQUFiLGFBQWE7a0JBRDNCLFNBQVM7OzBCQXFCZSxRQUFRO2lFQWpCUCxNQUFNO3NCQUE3QixLQUFLO3VCQUFDLGVBQWU7O0FBK0N4QixNQUNlLHFCQUFzQixTQUFRLGFBQWE7SUFDeEQsWUFBNEMsU0FBc0IsRUFBWSxJQUFZO1FBQ3hGLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFEbUIsY0FBUyxHQUFULFNBQVMsQ0FBYTtRQUFZLFNBQUksR0FBSixJQUFJLENBQVE7SUFFMUYsQ0FBQztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWlCLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNuRixDQUFDOztrSEFQWSxxQkFBcUI7c0dBQXJCLHFCQUFxQjsyRkFBckIscUJBQXFCO2tCQURuQyxTQUFTOzswQkFFZSxRQUFROztBQVNqQyxNQUNlLHVCQUF3QixTQUFRLGFBQWE7SUFDMUQsWUFBNEMsU0FBc0IsRUFBWSxJQUFZO1FBQ3hGLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFEbUIsY0FBUyxHQUFULFNBQVMsQ0FBYTtRQUFZLFNBQUksR0FBSixJQUFJLENBQVE7SUFFMUYsQ0FBQztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsa0JBQW1CLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyRixDQUFDOztvSEFQWSx1QkFBdUI7d0dBQXZCLHVCQUF1QjsyRkFBdkIsdUJBQXVCO2tCQURyQyxTQUFTOzswQkFFZSxRQUFROztBQVlqQyxNQUFNLE9BQU8scUJBQXNCLFNBQVEscUJBQXFCO0lBSzlELFlBQWtDLFNBQXNCLEVBQVksSUFBWTtRQUM5RSxLQUFLLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRFMsY0FBUyxHQUFULFNBQVMsQ0FBYTtRQUFZLFNBQUksR0FBSixJQUFJLENBQVE7UUFIaEYsd0RBQXdEO1FBQzlDLGVBQVUsR0FBNkIsSUFBSSxDQUFDLFlBQVksQ0FBQztJQUluRSxDQUFDO0lBRUQsUUFBUTtRQUNOLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLE9BQU8sQ0FBQyxNQUFjLEVBQUUsQ0FBZTtRQUMvQyxPQUFPLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQzs7a0hBcEJVLHFCQUFxQjtzR0FBckIscUJBQXFCOzJGQUFyQixxQkFBcUI7a0JBSGpDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLDZCQUE2QjtpQkFDeEM7OzBCQU1jLFFBQVE7aUVBRlgsVUFBVTtzQkFBbkIsTUFBTTs7QUF1QlQsTUFBTSxPQUFPLHdCQUF5QixTQUFRLHFCQUFxQjtJQUtqRSxZQUFrQyxTQUFzQixFQUFZLElBQVk7UUFDOUUsS0FBSyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQURTLGNBQVMsR0FBVCxTQUFTLENBQWE7UUFBWSxTQUFJLEdBQUosSUFBSSxDQUFRO1FBSGhGLDJEQUEyRDtRQUNqRCxrQkFBYSxHQUE2QixJQUFJLENBQUMsWUFBWSxDQUFDO0lBSXRFLENBQUM7SUFFRCxRQUFRO1FBQ04sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7OztPQUlHO0lBQ08sT0FBTyxDQUFDLE1BQWMsRUFBRSxDQUFlO1FBQy9DLE9BQU8sZ0JBQWdCLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNuRCxDQUFDOztxSEFwQlUsd0JBQXdCO3lHQUF4Qix3QkFBd0I7MkZBQXhCLHdCQUF3QjtrQkFIcEMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsbUNBQW1DO2lCQUM5Qzs7MEJBTWMsUUFBUTtpRUFGWCxhQUFhO3NCQUF0QixNQUFNOztBQXVCVCxNQUFNLE9BQU8sdUJBQXdCLFNBQVEsdUJBQXVCO0lBS2xFLFlBQWtDLFNBQXNCLEVBQVksSUFBWSxFQUFVLEdBQW1CO1FBQzNHLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFEUyxjQUFTLEdBQVQsU0FBUyxDQUFhO1FBQVksU0FBSSxHQUFKLElBQUksQ0FBUTtRQUFVLFFBQUcsR0FBSCxHQUFHLENBQWdCO1FBSDdHLDBEQUEwRDtRQUNoRCxpQkFBWSxHQUE2QixJQUFJLENBQUMsWUFBWSxDQUFDO0lBSXJFLENBQUM7SUFFRCxRQUFRO1FBQ04sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7OztPQUlHO0lBQ08sT0FBTyxDQUFDLE1BQWMsRUFBRSxDQUFlO1FBQy9DLE9BQU8sZ0JBQWdCLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUM1RyxDQUFDOztvSEFwQlUsdUJBQXVCO3dHQUF2Qix1QkFBdUI7MkZBQXZCLHVCQUF1QjtrQkFIbkMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsaUNBQWlDO2lCQUM1Qzs7MEJBTWMsUUFBUTs4RkFGWCxZQUFZO3NCQUFyQixNQUFNOztBQXVCVCxNQUFNLE9BQU8scUJBQXNCLFNBQVEsdUJBQXVCO0lBS2hFLFlBQWtDLFNBQXNCLEVBQVksSUFBWSxFQUFVLEdBQW1CO1FBQzNHLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFEUyxjQUFTLEdBQVQsU0FBUyxDQUFhO1FBQVksU0FBSSxHQUFKLElBQUksQ0FBUTtRQUFVLFFBQUcsR0FBSCxHQUFHLENBQWdCO1FBSDdHLHdEQUF3RDtRQUM5QyxlQUFVLEdBQTZCLElBQUksQ0FBQyxZQUFZLENBQUM7SUFJbkUsQ0FBQztJQUVELFFBQVE7UUFDTixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxPQUFPLENBQUMsTUFBYyxFQUFFLENBQWU7UUFDL0MsT0FBTyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQzFHLENBQUM7O2tIQXBCVSxxQkFBcUI7c0dBQXJCLHFCQUFxQjsyRkFBckIscUJBQXFCO2tCQUhqQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSw2QkFBNkI7aUJBQ3hDOzswQkFNYyxRQUFROzhGQUZYLFVBQVU7c0JBQW5CLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIE9wdGlvbmFsLCBJbnB1dCwgT3V0cHV0LCBPbkluaXQsIE9uRGVzdHJveSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xyXG5pbXBvcnQgeyBSdGxTY3JvbGxBeGlzVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XHJcbmltcG9ydCB7IE5nU2Nyb2xsYmFyIH0gZnJvbSAnbmd4LXNjcm9sbGJhcic7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIFN1YnNjcmlwdGlvbiwgU3Vic2NyaWJlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgdGFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbi8vIEZpeCB0YXJnZXQgdHlwZSBvbiBFbGVtZW50RXZlbnRcclxudHlwZSBFbGVtZW50RXZlbnQgPSBFdmVudCAmIHsgdGFyZ2V0OiBFbGVtZW50IH07XHJcblxyXG5jbGFzcyBSZWFjaGVkRnVuY3Rpb25zIHtcclxuICBzdGF0aWMgcmVhY2hlZFRvcChvZmZzZXQ6IG51bWJlciwgZTogRWxlbWVudEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC1lLnRhcmdldC5zY3JvbGxUb3AsIDAsIG9mZnNldCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcmVhY2hlZEJvdHRvbShvZmZzZXQ6IG51bWJlciwgZTogRWxlbWVudEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKGUudGFyZ2V0LnNjcm9sbFRvcCArIGUudGFyZ2V0LmNsaWVudEhlaWdodCwgZS50YXJnZXQuc2Nyb2xsSGVpZ2h0LCBvZmZzZXQpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHJlYWNoZWRTdGFydChvZmZzZXQ6IG51bWJlciwgZTogRWxlbWVudEV2ZW50LCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcsIHJ0bFNjcm9sbEF4aXNUeXBlOiBSdGxTY3JvbGxBeGlzVHlwZSk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcclxuICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5ORUdBVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZChlLnRhcmdldC5zY3JvbGxMZWZ0LCAwLCBvZmZzZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcclxuICAgICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC1lLnRhcmdldC5zY3JvbGxMZWZ0LCAwLCBvZmZzZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoZS50YXJnZXQuc2Nyb2xsTGVmdCArIGUudGFyZ2V0LmNsaWVudFdpZHRoLCBlLnRhcmdldC5zY3JvbGxXaWR0aCwgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoLWUudGFyZ2V0LnNjcm9sbExlZnQsIDAsIG9mZnNldCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgcmVhY2hlZEVuZChvZmZzZXQ6IG51bWJlciwgZTogRWxlbWVudEV2ZW50LCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcsIHJ0bFNjcm9sbEF4aXNUeXBlOiBSdGxTY3JvbGxBeGlzVHlwZSk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcclxuICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5ORUdBVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtKGUudGFyZ2V0LnNjcm9sbExlZnQgLSBlLnRhcmdldC5jbGllbnRXaWR0aCksIGUudGFyZ2V0LnNjcm9sbFdpZHRoLCBvZmZzZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcclxuICAgICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC0oZS50YXJnZXQuc2Nyb2xsTGVmdCArIGUudGFyZ2V0LmNsaWVudFdpZHRoKSwgZS50YXJnZXQuc2Nyb2xsV2lkdGgsIG9mZnNldCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtZS50YXJnZXQuc2Nyb2xsTGVmdCwgMCwgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoZS50YXJnZXQuc2Nyb2xsTGVmdCArIGUudGFyZ2V0LmNsaWVudFdpZHRoLCBlLnRhcmdldC5zY3JvbGxXaWR0aCwgb2Zmc2V0KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyByZWFjaGVkKGN1cnJQb3NpdGlvbjogbnVtYmVyLCB0YXJnZXRQb3NpdGlvbjogbnVtYmVyLCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGN1cnJQb3NpdGlvbiA+PSB0YXJnZXRQb3NpdGlvbiAtIG9mZnNldDtcclxuICB9XHJcbn1cclxuXHJcbkBEaXJlY3RpdmUoKVxyXG5hYnN0cmFjdCBjbGFzcyBTY3JvbGxSZWFjaGVkIGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuXHJcbiAgLyoqIG9mZnNldDogUmVhY2hlZCBvZmZzZXQgdmFsdWUgaW4gcHggKi9cclxuICBASW5wdXQoJ3JlYWNoZWRPZmZzZXQnKSBvZmZzZXQgPSAwO1xyXG5cclxuICAvKipcclxuICAgKiBTdHJlYW0gdGhhdCBlbWl0cyBzY3JvbGwgZXZlbnQgd2hlbiBgTmdTY3JvbGxiYXIuc2Nyb2xsZWRgIGlzIGluaXRpYWxpemVkLlxyXG4gICAqXHJcbiAgICogKipOT1RFOioqIFRoaXMgc3ViamVjdCBpcyB1c2VkIHRvIGhvbGQgdGhlIHBsYWNlIG9mIGBOZ1Njcm9sbGJhci5zY3JvbGxlZGAgd2hlbiBpdCdzIG5vdCBpbml0aWFsaXplZCB5ZXRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgc2Nyb2xsRXZlbnQgPSBuZXcgU3ViamVjdDxFbGVtZW50RXZlbnQ+KCk7XHJcblxyXG4gIC8qKiBzdWJzY3JpcHRpb246IFNjcm9sbGVkIGV2ZW50IHN1YnNjcmlwdGlvbiwgdXNlZCB0byB1bnN1YnNjcmliZSBmcm9tIHRoZSBldmVudCBvbiBkZXN0cm95ICovXHJcbiAgcHJvdGVjdGVkIHN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcclxuXHJcbiAgLyoqIEEgc3RyZWFtIHVzZWQgdG8gYXNzaWduIHRoZSByZWFjaGVkIG91dHB1dCAqL1xyXG4gIHByb3RlY3RlZCByZWFjaGVkRXZlbnQgPSBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxFbGVtZW50RXZlbnQ+KSA9PlxyXG4gICAgdGhpcy5zY3JvbGxSZWFjaGVkKCkuc3Vic2NyaWJlKF8gPT5cclxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLnpvbmUucnVuKCgpID0+IHN1YnNjcmliZXIubmV4dChfKSkpKSk7XHJcblxyXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgaWYgKCFzY3JvbGxiYXIpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdbTmdTY3JvbGxiYXJSZWFjaGVkIERpcmVjdGl2ZV06IEhvc3QgZWxlbWVudCBtdXN0IGJlIGFuIE5nU2Nyb2xsYmFyIGNvbXBvbmVudC4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBzY3JvbGxSZWFjaGVkKCk6IE9ic2VydmFibGU8RWxlbWVudEV2ZW50PiB7XHJcbiAgICAvLyBjdXJyZW50IGV2ZW50XHJcbiAgICBsZXQgY3VyckV2ZW50OiBFbGVtZW50RXZlbnQ7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsRXZlbnQucGlwZShcclxuICAgICAgdGFwKChlOiBFbGVtZW50RXZlbnQpID0+IGN1cnJFdmVudCA9IGUpLFxyXG4gICAgICAvLyBDaGVjayBpZiBpdCBzY3JvbGwgaGFzIHJlYWNoZWRcclxuICAgICAgbWFwKChlOiBFbGVtZW50RXZlbnQpID0+IHRoaXMucmVhY2hlZCh0aGlzLm9mZnNldCwgZSkpLFxyXG4gICAgICAvLyBEaXN0aW5jdCB1bnRpbCByZWFjaGVkIHZhbHVlIGhhcyBjaGFuZ2VkXHJcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgIC8vIEVtaXQgb25seSBpZiByZWFjaGVkIGlzIHRydWVcclxuICAgICAgZmlsdGVyKChyZWFjaGVkOiBib29sZWFuKSA9PiByZWFjaGVkKSxcclxuICAgICAgLy8gUmV0dXJuIHNjcm9sbCBldmVudFxyXG4gICAgICBtYXAoKCkgPT4gY3VyckV2ZW50KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFjaGVkKG9mZnNldDogbnVtYmVyLCBlPzogRWxlbWVudEV2ZW50KTogYm9vbGVhbjtcclxufVxyXG5cclxuQERpcmVjdGl2ZSgpXHJcbmFic3RyYWN0IGNsYXNzIFZlcnRpY2FsU2Nyb2xsUmVhY2hlZCBleHRlbmRzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgc3VwZXIoc2Nyb2xsYmFyLCB6b25lKTtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnNjcm9sbGJhci52ZXJ0aWNhbFNjcm9sbGVkIS5zdWJzY3JpYmUodGhpcy5zY3JvbGxFdmVudCk7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKClcclxuYWJzdHJhY3QgY2xhc3MgSG9yaXpvbnRhbFNjcm9sbFJlYWNoZWQgZXh0ZW5kcyBTY3JvbGxSZWFjaGVkIGltcGxlbWVudHMgT25Jbml0IHtcclxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcclxuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zY3JvbGxiYXIuaG9yaXpvbnRhbFNjcm9sbGVkIS5zdWJzY3JpYmUodGhpcy5zY3JvbGxFdmVudCk7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tyZWFjaGVkVG9wXSwgW3JlYWNoZWQtdG9wXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRUb3AgZXh0ZW5kcyBWZXJ0aWNhbFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHRvcCAqL1xyXG4gIEBPdXRwdXQoKSByZWFjaGVkVG9wOiBPYnNlcnZhYmxlPEVsZW1lbnRFdmVudD4gPSB0aGlzLnJlYWNoZWRFdmVudDtcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcclxuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIHN1cGVyLm5nT25Jbml0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHRvcCAodmVydGljYWxseSlcclxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcclxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogRWxlbWVudEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkVG9wKG9mZnNldCwgZSk7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tyZWFjaGVkQm90dG9tXSwgW3JlYWNoZWQtYm90dG9tXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRCb3R0b20gZXh0ZW5kcyBWZXJ0aWNhbFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIGJvdHRvbSAqL1xyXG4gIEBPdXRwdXQoKSByZWFjaGVkQm90dG9tOiBPYnNlcnZhYmxlPEVsZW1lbnRFdmVudD4gPSB0aGlzLnJlYWNoZWRFdmVudDtcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcclxuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIHN1cGVyLm5nT25Jbml0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIGJvdHRvbSAodmVydGljYWxseSlcclxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcclxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogRWxlbWVudEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkQm90dG9tKG9mZnNldCwgZSk7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tyZWFjaGVkU3RhcnRdLCBbcmVhY2hlZC1zdGFydF0nLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmdTY3JvbGxiYXJSZWFjaGVkU3RhcnQgZXh0ZW5kcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgc3RhcnQgKi9cclxuICBAT3V0cHV0KCkgcmVhY2hlZFN0YXJ0OiBPYnNlcnZhYmxlPEVsZW1lbnRFdmVudD4gPSB0aGlzLnJlYWNoZWRFdmVudDtcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUsIHByaXZhdGUgZGlyOiBEaXJlY3Rpb25hbGl0eSkge1xyXG4gICAgc3VwZXIoc2Nyb2xsYmFyLCB6b25lKTtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gICAgc3VwZXIubmdPbkluaXQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgc3RhcnQgKGhvcml6b250YWxseSlcclxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcclxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogRWxlbWVudEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkU3RhcnQob2Zmc2V0LCBlLCB0aGlzLmRpci52YWx1ZSwgdGhpcy5zY3JvbGxiYXIubWFuYWdlci5ydGxTY3JvbGxBeGlzVHlwZSk7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tyZWFjaGVkRW5kXSwgW3JlYWNoZWQtZW5kXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRFbmQgZXh0ZW5kcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgZW5kICovXHJcbiAgQE91dHB1dCgpIHJlYWNoZWRFbmQ6IE9ic2VydmFibGU8RWxlbWVudEV2ZW50PiA9IHRoaXMucmVhY2hlZEV2ZW50O1xyXG5cclxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSwgcHJpdmF0ZSBkaXI6IERpcmVjdGlvbmFsaXR5KSB7XHJcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xyXG4gIH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSBlbmQgKGhvcml6b250YWxseSlcclxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcclxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogRWxlbWVudEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkRW5kKG9mZnNldCwgZSwgdGhpcy5kaXIudmFsdWUsIHRoaXMuc2Nyb2xsYmFyLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUpO1xyXG4gIH1cclxufVxyXG4iXX0=